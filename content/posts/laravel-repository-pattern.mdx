---
title: Repository Pattern in Laravel
description: Learn how to implement the Repository Pattern in modern Laravel for clean, testable, and maintainable code.
author: Martin Duchev
date: "2025-06-02"
---

## Introduction

The Repository Pattern is a proven way to abstract your data access logic and keep your Laravel applications clean, modular, and testable. By separating business logic from the data layer, you can easily swap out data sources, mock repositories for testing, and keep your controllers slim.

---

## Why Use the Repository Pattern in Laravel?

- **Separation of concerns:** Keeps controllers and services free from database logic.
- **Easier testing:** You can mock repositories in your tests.
- **Centralized data logic:** All queries for a model are in one place.

---

## Example: Implementing the Repository Pattern in Laravel 11

Let's walk through a simple example using an `Article` model.

### 1. Create the Model and Migration

```bash
php artisan make:model Article -m
```

Edit the migration to add fields:

```php
public function up()
{
    Schema::create('articles', function (Blueprint $table) {
        $table->id();
        $table->string('title');
        $table->text('content');
        $table->timestamps();
    });
}
```

Run the migration:

```bash
php artisan migrate
```

---

### 2. Define the Repository Interface

```php
namespace App\Repositories;

use App\Models\Article;

interface ArticleRepositoryInterface
{
    public function all();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}
```

---

### 3. Implement the Repository

```php
namespace App\Repositories;

use App\Models\Article;

class ArticleRepository implements ArticleRepositoryInterface
{
    public function all()
    {
        return Article::all();
    }

    public function find($id)
    {
        return Article::findOrFail($id);
    }

    public function create(array $data)
    {
        return Article::create($data);
    }

    public function update($id, array $data)
    {
        $article = Article::findOrFail($id);
        $article->update($data);
        return $article;
    }

    public function delete($id)
    {
        return Article::destroy($id);
    }
}
```

---

### 4. Bind the Interface to the Implementation

Add this to your `AppServiceProvider`:

```php
use App\Repositories\ArticleRepositoryInterface;
use App\Repositories\ArticleRepository;

public function register()
{
    $this->app->bind(ArticleRepositoryInterface::class, ArticleRepository::class);
}
```

---

### 5. Use the Repository in a Controller

```php
namespace App\Http\Controllers;

use App\Repositories\ArticleRepositoryInterface;
use Illuminate\Http\Request;

class ArticleController extends Controller
{
    protected $articles;

    public function __construct(ArticleRepositoryInterface $articles)
    {
        $this->articles = $articles;
    }

    public function index()
    {
        $articles = $this->articles->all();
        return view('articles.index', compact('articles'));
    }

    public function store(Request $request)
    {
        $this->articles->create($request->only(['title', 'content']));
        return redirect()->route('articles.index');
    }
}
```

---

## Conclusion

The Repository Pattern in Laravel helps you keep your codebase clean and maintainable by abstracting data access logic. Itâ€™s especially useful for large projects and when writing tests. By following this pattern, you can easily swap out data sources, mock repositories, and keep your controllers focused on handling HTTP requests and responses.

Happy coding!